{
  "research_area": "Sequence Analysis",
  "description": "Sequence analysis is a fundamental aspect of bioinformatics that involves the examination of DNA, RNA, or protein sequences to derive meaningful biological information. It encompasses a wide range of techniques, including sequence alignment, motif discovery, sequence assembly, variant detection, and phylogenetic analysis. With the evolution of sequencing technologies from short to long reads, the computational methods for sequence analysis continue to adapt to provide more comprehensive insights into genomic data.",
  "key_concepts": [
    "Global and local sequence alignment",
    "Pairwise and multiple sequence alignment",
    "Sequence homology and similarity",
    "Motif discovery and enrichment analysis",
    "Phylogenetic tree construction and analysis",
    "Long-read sequencing analysis (PacBio, Oxford Nanopore)",
    "Sequence assembly (de novo and reference-guided)",
    "Consensus sequence generation",
    "Open reading frame (ORF) prediction",
    "Sequence annotation and functional prediction"
  ],
  "common_tools": [
    "BLAST/DIAMOND - Sequence similarity search",
    "MAFFT/Clustal Omega/T-Coffee - Multiple sequence alignment",
    "HMMER - Profile hidden Markov models for sequence analysis",
    "MEME Suite - Motif discovery and analysis",
    "IQ-TREE/RAxML/FastTree - Phylogenetic inference",
    "Minimap2 - Long-read alignment",
    "Canu/Flye - Long-read assembly",
    "MEGA - Molecular evolutionary genetics analysis",
    "EMBOSS - Sequence analysis package",
    "CD-HIT - Sequence clustering"
  ],
  "common_file_formats": [
    {
      "name": "FASTA",
      "description": "Nucleotide or protein sequences without quality scores"
    },
    {
      "name": "FASTQ",
      "description": "Nucleotide sequences with quality scores"
    },
    {
      "name": "CLUSTAL/STOCKHOLM",
      "description": "Multiple sequence alignment formats"
    },
    {
      "name": "NEWICK/NEXUS/PHYLIP",
      "description": "Phylogenetic tree formats"
    },
    {
      "name": "GenBank/EMBL/GFF",
      "description": "Annotated sequence formats"
    },
    {
      "name": "BAM/SAM",
      "description": "Sequence alignment formats"
    },
    {
      "name": "VCF",
      "description": "Variant call format"
    }
  ],
  "examples": [
    {
      "query": "How do I perform phylogenetic analysis for a set of protein sequences?",
      "context": "The user has 50 homologous protein sequences in FASTA format from different bacterial species and wants to understand their evolutionary relationships.",
      "response": "\n# Phylogenetic Analysis of Bacterial Protein Sequences\n\n## Approach Overview\nFor phylogenetic analysis of bacterial protein sequences, you'll need to:\n1. Align the sequences\n2. Select an appropriate evolutionary model\n3. Build a phylogenetic tree\n4. Evaluate tree reliability\n\n## Key Decision Points\n\n### Multiple Sequence Alignment (MSA)\n- **For <200 sequences with moderate divergence**: Use MAFFT with L-INS-i (--localpair --maxiterate 1000)\n- **For larger datasets**: Use MAFFT with FFT-NS-2 (default) or MUSCLE\n- **For highly divergent sequences**: Consider T-Coffee or PROMALS3D which can incorporate structural information\n\nThe accuracy of your alignment is critical - always visualize and inspect it before proceeding.\n\n```bash\n# Example for medium-sized datasets with moderate divergence\nmafft --localpair --maxiterate 1000 --reorder protein_sequences.fasta > aligned_proteins.fasta\n```\n\n### Trimming Alignments\nRemoving poorly aligned regions can improve tree inference:\n- **Automated trimming**: Use trimAl or Gblocks\n- **Manual trimming**: For smaller datasets, use Jalview or AliView\n\nWhether to trim depends on your sequences - conserved proteins may not need trimming, while divergent sequences benefit from it.\n\n### Evolutionary Model Selection\nThe choice of evolutionary model significantly impacts tree accuracy:\n- **Automated selection**: Use ModelFinder (in IQ-TREE) or ProtTest\n- **Common protein models**: LG, WAG, or JTT with rate heterogeneity (+G)\n- **For prokaryotic proteins**: LG+G is often a good starting point\n\n```bash\n# Model selection with IQ-TREE\niqtree -s aligned_proteins.fasta -m MFP -mfreq -msub nuclear\n```\n\n### Tree Building Method\nDifferent methods have different strengths:\n- **Maximum Likelihood**: IQ-TREE or RAxML (most commonly used for modern analyses)\n- **Bayesian Inference**: MrBayes or BEAST (when prior information is available)\n- **Distance-Based**: FastME or Neighbor-Joining (for quick initial trees)\n\nFor bacterial proteins, Maximum Likelihood with IQ-TREE offers an excellent balance of accuracy and speed.\n\n```bash\n# Maximum Likelihood tree with IQ-TREE\niqtree -s aligned_proteins.fasta -m LG+G4 -bb 1000 -alrt 1000\n```\n\n### Tree Reliability Assessment\nAlways evaluate support for your tree topology:\n- **Bootstrap support**: Values >70% indicate reliable branches\n- **SH-aLRT test**: Provides faster assessment than traditional bootstrapping\n- **Ultrafast Bootstrap (UFBoot)**: Faster than standard bootstrapping but may be overconfident\n\nAssess the tree with multiple approaches when possible. For publication-quality trees, 1000 bootstrap replicates are typically expected.\n\n## Interpretation Considerations\n- Branches with low support (<70% bootstrap) should be interpreted with caution\n- Consider gene-specific evolutionary rates when interpreting branch lengths\n- Horizontal gene transfer in bacteria may cause individual gene trees to differ from species trees\n- Outgroup selection can significantly affect tree topology - choose an appropriate outgroup that is not too distant\n\n## Visualization\nFor effective tree visualization:\n- **Interactive exploration**: Use FigTree, iTOL, or Dendroscope\n- **Publication figures**: Use ggtree (in R) for customizable, publication-quality images\n- **Annotating trees**: Add metadata like habitat, pathogenicity, or geographic origin\n\n## When to Consider Alternative Approaches\n- **For very large datasets** (>1000 sequences): Consider FastTree or IQ-TREE with fast models\n- **For highly divergent sequences**: Consider using protein domains rather than full sequences\n- **For closely related sequences**: Use nucleotide sequences instead of proteins\n- **For dataset with insertion/deletion bias**: Consider phylogenetic placement instead of de novo tree building\n"
    },
    {
      "query": "What approach should I use to identify protein motifs in a set of sequences?",
      "context": "The user has extracted 200 protein sequences that are co-expressed in response to stress and wants to identify shared functional motifs.",
      "response": "\n# Identifying Protein Motifs in Stress-Response Proteins\n\n## Approach Overview\nTo identify functional motifs in stress-response proteins, you'll need to:\n1. Prepare and filter your sequence dataset\n2. Perform de novo motif discovery\n3. Compare with known motifs\n4. Validate motifs with structural and functional analysis\n\n## Key Decision Points\n\n### Dataset Preparation\n- **Sequence redundancy**: Remove highly similar sequences (typically >90% identity)\n- **Sequence length**: Group by similar lengths or domains\n- **Background sequences**: Select appropriate negative dataset (non-stress-responsive proteins)\n\n```python\n# Example of redundancy reduction using CD-HIT\nfrom Bio import SeqIO\nimport subprocess\n\n# Write sequences to file\nSeqIO.write(sequences, \"stress_proteins.fasta\", \"fasta\")\n\n# Run CD-HIT with 90% identity threshold\nsubprocess.run([\"cd-hit\", \"-i\", \"stress_proteins.fasta\", \"-o\", \"nr_proteins.fasta\", \"-c\", \"0.9\"])\n```\n\n### De Novo Motif Discovery\nChoose the right algorithm based on your expectations about the motifs:\n\n- **For short, ungapped motifs** (e.g., transcription factor binding sites):\n  - MEME (with -mod zoops or -mod anr)\n  - STREME (successor to DREME, for short motifs)\n\n- **For longer, structured motifs** (e.g., enzyme active sites):\n  - GLAM2 (allows for insertions/deletions)\n  - HMMER (if you have an initial alignment of the motif region)\n\n- **For periodic or spaced motifs**:\n  - MEME with appropriate gap parameters\n  - MAST for scanning with complex motif models\n\n```bash\n# Example for discovering ungapped motifs with MEME\nmeme nr_proteins.fasta -protein -oc meme_output -nmotifs 5 -minw 6 -maxw 50 -mod zoops\n```\n\n### Comparing with Known Motifs\nAfter discovering motifs, determine if they're novel or known:\n\n- **For known motif comparison**:\n  - Search against ELM (Eukaryotic Linear Motif) database for short functional motifs\n  - Search PROSITE or Pfam for domain signatures\n  - Use Tomtom to compare against motif databases\n\n- **Parameters to consider**:\n  - E-value thresholds (typically 0.05 for initial screening)\n  - Query coverage (how much of your motif matches the database entry)\n  - Conservation across species (conserved motifs are more likely functional)\n\n```bash\n# Example of comparing discovered motifs to known databases\ntomtom -oc tomtom_output -min-overlap 5 -dist pearson -thresh 0.05 meme_output/meme.xml motif_database.meme\n```\n\n### Structural Context Analysis\nEvaluate the structural context of your motifs:\n\n- **For proteins with known structures**:\n  - Map motifs onto 3D structures using PyMOL or UCSF Chimera\n  - Check if motifs are in structured domains or disordered regions\n  \n- **For proteins without structures**:\n  - Use structure prediction tools like AlphaFold2\n  - Predict disordered regions using IUPred or PONDR\n  - Predict secondary structure using PSIPRED\n\n- **Key features to look for**:\n  - Surface accessibility (functional motifs often surface-exposed)\n  - Conservation of 3D arrangement in different proteins\n  - Proximity to active sites or binding interfaces\n\n## Interpretation Considerations\n\n### Biological Validation Strategies\nConsider how to validate predicted motifs:\n- Functional assays with site-directed mutagenesis\n- Peptide array binding experiments\n- Evolutionary conservation analysis across diverse species\n\n### Motif Classification\nBased on your analysis, classify motifs by:\n\n- **Function**:\n  - Catalytic motifs (e.g., active site signatures)\n  - Binding motifs (e.g., protein-protein interaction sites)\n  - PTM sites (e.g., phosphorylation motifs)\n  - Localization signals (e.g., nuclear localization sequences)\n\n- **Structure**:\n  - Secondary structure elements (\u03b1-helices, \u03b2-strands)\n  - Disordered region motifs (often linear motifs)\n  - Metal-binding motifs (e.g., zinc fingers)\n\n### Stress-Response Specific Considerations\nFor stress-response proteins specifically:\n- Look for known stress-related motifs (heat shock elements, oxidative stress response elements)\n- Consider condition-specific motifs that may be activated only under specific stressors\n- Examine motif conservation across different stress conditions\n- Compare with motifs in proteins with similar function but different regulation\n"
    },
    {
      "query": "How do I analyze long-read sequencing data for detecting structural variants?",
      "context": "The user has Oxford Nanopore whole genome sequencing data from a human sample and wants to identify structural variants.",
      "response": "\n# Structural Variant Detection with Long-Read Sequencing\n\n## Approach Overview\nTo detect structural variants (SVs) using Oxford Nanopore long-read data:\n1. Prepare and QC your sequencing data\n2. Align reads to a reference genome\n3. Apply SV detection algorithms\n4. Filter and validate candidate SVs\n\n## Key Decision Points\n\n### Data Quality Assessment\n- **Read length distribution**: Longer reads (>10kb) improve SV detection\n- **Coverage requirements**: \n  - Minimum 15-20x for large SVs (>1kb)\n  - 30x+ recommended for comprehensive detection\n  - 50x+ for detecting low-frequency somatic variants\n- **Base quality**: Consider re-basecalling with latest models if using older data\n\n```python\n# Example code snippet to check read length distribution\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom Bio import SeqIO\n\n# Load read lengths\nlengths = [len(record) for record in SeqIO.parse(\"reads.fastq\", \"fastq\")]\n\n# Plot histogram\nplt.figure(figsize=(10, 6))\nplt.hist(lengths, bins=50, alpha=0.75)\nplt.title(\"Read Length Distribution\")\nplt.xlabel(\"Read Length (bp)\")\nplt.ylabel(\"Frequency\")\nplt.axvline(np.median(lengths), color='r', linestyle='dashed', linewidth=1)\nplt.text(np.median(lengths)*1.1, plt.ylim()[1]*0.9, f\"Median: {np.median(lengths):.0f} bp\")\nplt.savefig(\"read_length_dist.png\")\n```\n\n### Alignment Strategy\n- **Aligner selection**:\n  - Minimap2 (most widely used, excellent balance of speed and accuracy)\n  - NGMLR (slower but may perform better for certain SV types)\n  - LAST (older but sometimes better for highly divergent sequences)\n\n- **Alignment parameters**:\n  - For human genomes, use the \"map-ont\" preset in Minimap2\n  - Adjust mapping quality thresholds based on your data quality\n  - Consider masking problematic regions (e.g., centromeres, telomeres)\n\n### SV Detection Tools\nDifferent SV callers have different strengths - use multiple for comprehensive detection:\n\n- **Primary SV callers**:\n  - Sniffles2 (excellent all-around performance)\n  - SVIM (good sensitivity, especially for insertions)\n  - cuteSV (high performance, good for complex SVs)\n  - NanoSV (specifically designed for ONT data)\n\n- **SV caller selection based on variant type**:\n  - For deletions: Most callers perform similarly well\n  - For insertions: SVIM and Sniffles2 typically perform best\n  - For inversions and translocations: Consider specialized callers or manual verification\n\n### SV Filtering and Merging\n- **Filtering parameters**:\n  - Read support (typically \u22653-5 reads for germline variants)\n  - Mapping quality (usually \u226520)\n  - SV length (based on your research question)\n  - Proximity to difficult regions\n\n- **Multi-caller approach**:\n  - Use SURVIVOR or SVDB to merge calls from multiple tools\n  - Require SV detection by at least 2 independent methods\n  - Allow for positioning differences (typically 500-1000bp for large SVs)\n\n```bash\n# Example SURVIVOR command (conceptual)\nSURVIVOR merge callsets.txt 1000 2 1 1 0 50 merged_SVs.vcf\n# Parameters: max distance (1000bp), min callers (2), consider type/strands/regions (1/1/0), min size (50bp)\n```\n\n## Interpretation Considerations\n\n### SV Classification\nUnderstand the different classes of SVs:\n- **Deletions**: Usually the most reliably detected\n- **Insertions**: Challenging due to reference bias, but long reads excel here\n- **Duplications**: Look for read depth evidence in addition to split reads\n- **Inversions**: Require reads spanning both breakpoints\n- **Translocations**: High false positive rate, require careful validation\n\n### Validating SVs\nConsider these validation approaches:\n- **Orthogonal technologies**: PCR, optical mapping, linked-reads\n- **Manual inspection**: IGV visualization of discordant reads and split alignments\n- **Population frequency**: Check databases like gnomAD-SV for known variants\n- **Local assembly**: Assemble reads around breakpoints for precise SV characterization\n\n### Long-Read Specific Advantages\nLeverage the unique strengths of long reads:\n- The ability to span entire SVs and complex regions\n- Better resolution of breakpoints\n- Detection of insertions and novel sequences\n- Resolution of SVs in repetitive regions\n\n### Known Challenges\nBe aware of these common issues:\n- Tandem repeats and segmental duplications remain challenging\n- Alignment errors in low-complexity regions\n- Higher error rates can affect precise breakpoint detection\n- Limited databases of known SVs compared to SNVs\n\n## Follow-up Analysis\nAfter identifying SVs, consider:\n- Annotating SVs with gene impacts using AnnotSV or SnpEff\n- Pathway enrichment analysis for affected genes\n- Comparing SVs across related samples\n- Correlating SVs with phenotypic data if available\n"
    },
    {
      "query": "What are the key considerations for de novo genome assembly with long reads?",
      "context": "The user is planning an Oxford Nanopore sequencing project to assemble a novel bacterial genome and wants to understand the key decisions in the assembly process.",
      "response": "\n# De Novo Genome Assembly with Long Reads\n\n## Approach Overview\nFor de novo assembly of a bacterial genome with Oxford Nanopore long reads:\n1. Plan your sequencing strategy\n2. Process and assess read quality\n3. Select appropriate assembly methods\n4. Polish and validate your assembly\n\n## Key Decision Points\n\n### Sequencing Strategy\n- **Coverage requirements**:\n  - For bacterial genomes: 50-100x for high-quality assembly\n  - Higher coverage compensates for lower accuracy of individual reads\n  - Diminishing returns above ~100x coverage\n  \n- **Read length considerations**:\n  - Longer reads (>20kb) improve contiguity dramatically\n  - Library prep methods affect read length (ligation > rapid > transposase)\n  - Ultra-long reads (>100kb) can span most bacterial repeats\n  \n- **DNA extraction**:\n  - High molecular weight extraction methods preserve long fragments\n  - Avoid excessive shearing during extraction\n  - Consider specialized kits for difficult-to-lyse bacteria\n\n### Quality Control and Preprocessing\n- **Read filtering decisions**:\n  - Quality score threshold (typically Q7-Q10)\n  - Minimum read length (typically 1-5kb)\n  - Adaptor trimming and chimera removal\n  \n- **Contamination screening**:\n  - BLAST-based classification of reads\n  - Kraken2/Centrifuge for metagenomic screening\n  - Identification of host contamination\n\n```python\n# Example: Quick assessment of potential read contamination\nfrom Bio import SeqIO\nimport subprocess\nimport random\n\n# Randomly sample reads for faster processing\nsampled_reads = random.sample([rec for rec in SeqIO.parse(\"reads.fastq\", \"fastq\")], 1000)\nSeqIO.write(sampled_reads, \"sampled_reads.fasta\", \"fasta\")\n\n# Run Kraken2 for taxonomic classification\nsubprocess.run([\"kraken2\", \"--db\", \"kraken_db\", \"sampled_reads.fasta\", \n                \"--output\", \"kraken_out.txt\", \"--report\", \"kraken_report.txt\"])\n```\n\n### Assembler Selection\n- **Flye**:\n  - Ideal for bacterial genomes\n  - Excels with varied coverage and read lengths\n  - Good repeat resolution\n  - Efficient computation usage\n  \n- **Canu**:\n  - Produces highly accurate assemblies\n  - More computationally intensive\n  - Works well with lower coverage\n  - Good error correction\n  \n- **Raven/wtdbg2**:\n  - Faster assembly with lower resource usage\n  - Slightly less accurate\n  - Good for quick preliminary assemblies\n  \n- **Specialized applications**:\n  - Unicycler for hybrid Illumina/Nanopore data\n  - NECAT for challenging genomes\n  - Shasta for human-scale genomes\n\n### Assembly Polishing Strategy\n- **Long-read polishing**:\n  - Medaka (Oxford Nanopore-specific polisher)\n  - Racon (general consensus tool)\n  - Multiple rounds may be beneficial\n  \n- **Short-read polishing (if available)**:\n  - Pilon or NextPolish\n  - Significantly reduces error rate\n  - 2-3 rounds typically sufficient\n  \n- **Polishing evaluation**:\n  - BUSCO scores to track improvement\n  - Error rate estimation with mapping quality\n  - Diminishing returns after 2-3 rounds\n\n### Circular Genome Handling\nFor bacterial genomes:\n- Check if assembly is circular (ends overlap)\n- Rotate to start at a standard gene (e.g., dnaA or other origin)\n- Remove duplicate sequence at ends\n- Tools: Circlator or manual inspection\n\n## Interpretation Considerations\n\n### Assembly Quality Assessment\nEvaluate your assembly using multiple metrics:\n- **Contiguity**: N50, largest contig, number of contigs\n- **Completeness**: BUSCO or CheckM scores\n- **Accuracy**: Consensus accuracy, mapping quality\n- **Structural correctness**: Alignment to reference genomes of related species\n\n```python\n# Example: Calculating basic assembly stats\nfrom Bio import SeqIO\n\nassembly = [rec for rec in SeqIO.parse(\"assembly.fasta\", \"fasta\")]\nlengths = sorted([len(rec) for rec in assembly], reverse=True)\ntotal_length = sum(lengths)\n\nn50 = 0\nrunning_sum = 0\nfor length in lengths:\n    running_sum += length\n    if running_sum >= total_length * 0.5:\n        n50 = length\n        break\n\nprint(f\"Assembly size: {total_length:,} bp\")\nprint(f\"Number of contigs: {len(lengths)}\")\nprint(f\"Largest contig: {lengths[0]:,} bp\")\nprint(f\"N50: {n50:,} bp\")\n```\n\n### Common Assembly Challenges\n- **Repeat regions**:\n  - Check coverage drops in repeat regions\n  - Look for collapse or expansion of repeats\n  - Consider manual curation of known difficult regions\n  \n- **GC bias**:\n  - Check for gaps in extreme GC content regions\n  - May need coverage-aware assembly parameters\n  \n- **Contamination**:\n  - Unexpected contig sizes or numbers\n  - BLAST or taxonomic analysis of small contigs\n  - CheckM for detecting mixed genomes\n\n### Post-Assembly Analysis\nAfter successful assembly:\n- Gene prediction with Prokka\n- Comparative genomics with related species\n- Functional annotation\n- Identification of genomic islands and horizontal gene transfer\n\n## Technology-Specific Considerations\n- **Error profile**:\n  - ONT reads have higher indel than substitution error rates\n  - Homopolymer regions are particularly challenging\n  - Systematic errors in certain sequence contexts\n  \n- **Basecalling improvement**:\n  - Re-basecalling with newer models can improve assembly\n  - High-accuracy basecalling modes trade speed for accuracy\n  - Consider GPU acceleration for basecalling\n"
    }
  ],
  "references": [
    "Altschul SF, et al. (1990). Basic local alignment search tool. Journal of Molecular Biology.",
    "Katoh K, Standley DM. (2013). MAFFT multiple sequence alignment software version 7: improvements in performance and usability. Molecular Biology and Evolution.",
    "Li H. (2018). Minimap2: pairwise alignment for nucleotide sequences. Bioinformatics.",
    "Bailey TL, et al. (2009). MEME SUITE: tools for motif discovery and searching. Nucleic Acids Research.",
    "Nguyen LT, et al. (2015). IQ-TREE: a fast and effective stochastic algorithm for estimating maximum-likelihood phylogenies. Molecular Biology and Evolution.",
    "Kolmogorov M, et al. (2019). Assembly of long, error-prone reads using repeat graphs. Nature Biotechnology."
  ]
}